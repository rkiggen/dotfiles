#+TITLE: Rob Kiggen's Emacs configuration
#+AUTHOR: Rob Kiggen
#+EMAIL: robby.kiggen@essential-it.be
#+STARTUP: hidestars
#+OPTIONS: ^:nil # Disable underscore causing subscript
#+OPTIONS: toc:4 h:4
* Introduction
** Quotations
*** On Emacs
#+begin_quote
Emacs outshines all other editing software in approximately the same way that the noonday sun does the stars. It is not
just bigger and brighter; it simply makes everything else vanish.
-- Neal Stephenson, "[[http://www.cryptonomicon.com/beginning.html][In the Beginning was the Command Line]]"
#+end_quote
#+begin_quote
On 2 Apr 1992 in the journal Nature the discovery was reported that a giant ancient fungus had been living under the
forests of Michigan for at least 1,500 years, the oldest and largest living thing on Earth. Software could get to be
like that, I suppose, and Emacs, incorporating, like the fungal thallus, all the the filamentous strands of Emacs Lisp
that now already thinly web the Earth, is surely a front runner. But do not be distracted by such lives.  Even the life
of Emacs, like the life of that fungus, is an ephemerality; to grok life one must transcend not only thermospace but
cyberspace.
-- [[http://www.eskimo.com/~seldon/dotemacs.el][Will Mengarini]]
#+end_quote

*** On Literate Programming
#+begin_quote
Let us change our traditional attitude to the construction of programs: Instead of imagining that our main task is to
instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do.

The practitioner of literate programming can be regarded as an essayist, whose main concern is with exposition and
excellence of style. Such an author, with thesaurus in hand, chooses the names of variables carefully and explains what
each variable means. He or she strives for a program that is comprehensible because its concepts have been introduced in
an order that is best for human understanding, using a mixture of formal and informal methods that reinforce each
other.

-- Donald Knuth
#+end_quote
#+begin_quote
In my experience, software created with literate programming has turned out to be significantly better than software developed in more traditional ways...

Jon Bentley probably hit the nail on the head when he once was asked why literate programming hasn’t taken the whole
world by storm. He observed that a small percentage of the world’s population is good at programming, and a small
percentage is good at writing; apparently I am asking everybody to be in both subsets.

Yet to me, literate programming is certainly the most important thing that came out of the TeX project. Not only has it
enabled me to write and maintain programs faster and more reliably than ever before, and been one of my greatest sources
of joy since the 1980s—it has actually been indispensable at times.

-- [[http://www.informit.com/articles/article.aspx?p=1193856][Donald Knuth]]
#+end_quote

* Initialization
** Enable Package Support
*** Use-Package
Use-package is a handful of things: you can make sure a package is downloaded, efficiently configure it (e.g. after
load, or as needed), bind keys in a concise way, and more.

First we need to specify the repositories from which we'll load packages. Setting =package-enable-at-startup= to =nil=
prevents a second package load and slightly improves startup time.

Package sources should be defined before we can install any packages at all, including =use-package=.

#+BEGIN_SRC emacs-lisp
(require 'package)
(setq package-archives
      '(("melpa" . "https://melpa.org/packages/")
        ("gnu" . "https://elpa.gnu.org/packages/")
        ("org" . "http://orgmode.org/elpa/")))
(setq package-enable-at-startup nil)
#+END_SRC

If =use-package= is not installed, install it.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
#+END_SRC

By default all packages should be installed from package manager as that's the usual path. This is equivalent to setting
=:ensure t= on each call to =use-package=. To disable set =:ensure nil= (this is done automatically for any packages
using =:load-path= so shouldn't generally be needed).

#+BEGIN_SRC emacs-lisp
(setq use-package-always-ensure t)
#+END_SRC

*** Async

Async enables asynchronous processing in Emacs, as well as some basic implementations of asynchronous capabilities
(e.g. for dired and packages and so on).

#+BEGIN_SRC emacs-lisp
  (use-package async
    :init
    (autoload 'dired-async-mode "dired-async.el" nil t)
    (dired-async-mode 1)
    (async-bytecomp-package-mode 1)
    (autoload 'dired-async-mode "dired-async.el" nil t)
    (async-bytecomp-package-mode 1)
    (dired-async-mode 1)
    (require 'smtpmail-async)
    (setq send-mail-function 'async-smtpmail-send-it))
#+END_SRC

** Startup
With the functions below we'll log the startup time of the individual packages so we can easily identify why it takes a
long time to startup Emacs. Furthermore we adjust some settings which improve the startup time.

*** Log Startup Times
=benchmark-init= records startup time by package so we can debug. It only records things after it's initialised, so put
as early in config as possible.

#+BEGIN_SRC emacs-lisp
  (use-package benchmark-init
    :config
    ;; To disable collection of benchmark data after init is done.
    (add-hook 'after-init-hook 'benchmark-init/deactivate))

  (add-hook 'after-init-hook
            (lambda () (message "loaded in %s" (emacs-init-time))))
#+END_SRC

*** Improve Startup Speed
The default garbage collection threshold is 800kB, increasing this to 10MB for
startup increases speed (from 11.0s -> 9.7s when I tested).

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 10000000)

  ;; Restore after startup
  (add-hook 'after-init-hook
            (lambda ()
              (setq gc-cons-threshold 1000000)
              (message "gc-cons-threshold restored to %S"
                       gc-cons-threshold)))
#+END_SRC

** Detection
*** Detect Operating System

These functions identify what operating system is hosting Emacs, which can be handy for system specific configuration. I
have run Emacs on Windows and Linux. I currently use Windows most of the time, and Linux some of the time, so my
configuration is geared towards those. Still, I may want to run my configuration on OS X or BSD in the future so I
include those functions.

#+BEGIN_SRC emacs-lisp
  (defun is-windows-p
      ()
    (or
     (eq system-type 'ms-dos)
     (eq system-type 'windows-nt)
     (eq system-type 'cygwin)))

  (defun is-linux-p
      ()
    (eq system-type 'gnu/linux))

  (defun is-mac-p
      ()
    (eq system-type 'darwin))

  (defun is-bsd-p
      ()
    (eq system-type 'gnu/kfreebsd))
#+END_SRC

*** Detect Internet Connection
#+BEGIN_SRC emacs-lisp
  (defun internet-up-p (&optional host)
    (= 0 (call-process "ping" nil nil nil "-c" "1" "-W" "1"
                       (if host host "www.google.com"))))
#+END_SRC

** Various
*** Custom Packages
By default Emacs only includes files directly under =user-emacs-directory= (usually =~/.emacs.d/=), so we need to add
any folders containing custom packages.

I put my scripts under =~/dotfiles/lisp/= and symlink it with =ln -s ~/dotfiles/lisp ~/.emacs.d/lisp=.

The code below will load all packages present in the lisp folder and its subfolders.

#+BEGIN_SRC emacs-lisp
;  (add-to-list 'load-path "~/.emacs.d/lisp/")
(let ((default-directory  "~/.emacs.d/lisp/"))
  (normal-top-level-add-to-load-path '("."))
  (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

*** Control Variables

Here we set the custom settings to load in its own file, This stops emacs adding customised settings to =init.el=. I try
to avoid using customize anyway, preferring programmatic control of variables. Creating it as a temporary file
effectively disables it (i.e. any changes are session local).

#+BEGIN_SRC emacs-lisp
  (setq custom-file (make-temp-file "emacs-custom"))
#+END_SRC

* Settings
Configuration of standard Emacs functionality
** Personal information
Specify the user information

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Robby Kiggen"
        user-mail-address "robby.kiggen@essential-it.be"
        calendar-latitude 51.251094
        calendar-longitude 5.545544
        calendar-location-name "Hamont, Belgium")
#+END_SRC

** Graphical Features
*** Start Maximized
Starting from Emacs 24.4 you can either run Emacs with the ‘--maximized’ command-line option or put the following form
 in your .emacs file:

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-startup-hook 'toggle-frame-maximized)
;;(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+END_SRC

To avoid the slightly distracting visual effect of Emacs starting with its default frame size and then growing to
fullscreen, you can add an ‘Emacs.Geometry’ entry to the Windows registry settings. See [[https://www.gnu.org/software/emacs/manual/html_node/emacs/X-Resources.html#X-Resources][X Resources]].

*** Themes

Load some themes and make it possible to change themes with the following commands:
=C-c t n=  load next theme
=C-c t p= load previous theme

#+BEGIN_SRC emacs-lisp
(use-package atom-one-dark-theme
    :ensure t
    :defer t)

(use-package panda-theme
    :ensure t
    :defer t)
 (use-package monokai-theme
    :ensure t
    :defer t)

 (use-package wh-theming
    :load-path "lisp/"
    :demand t
    :bind (("C-c t n" . wh/theming-load-next-theme)
           ("C-c t p" . wh/theming-load-prev-theme))
    :init
    (setq wh/term-theme 'panda
          wh/gui-themes '(atom-one-dark
  		          monokai
			  panda))
    :config
    (if (memq window-system '(mac ns))
        (wh/theming-load-random-theme)
      (load-theme wh/term-theme t)))
#+END_SRC

*** Font

Set the default font and face-attribute:

#+BEGIN_SRC emacs-lisp
  ;; (set-default-font "Source Code Pro" nil t)
  (set-frame-font "FiraCode" nil t)
  (set-face-attribute 'default nil :height 150)
#+END_SRC

*** Pretify Symbols
The purpose of the =pretify-symbols-mode= is to replace the standard text representation of various identifiers/symbols
with a (arguably) more aesthetically pleasing representation (often a single unicode character would replace several
ascii characters).

A classic example would be lambda from various Lisp dialects that many people prefer to replace with the greek letter λ
(small lambda).

#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode +1)
#+END_SRC

*** Cursor

Show the cursor position column number in the bottom left of the screen:
#+BEGIN_SRC emacs-lisp :results none
  (column-number-mode)
#+END_SRC

I like to display a different cursor depending on the edit mode:
1. Insert mode: either '_' (hbar) or '|'  (bar);
2. Overwrite mode: block cursor

#+BEGIN_SRC emacs-lisp :results none
;; vertical bar cursor by default
(set-default 'cursor-type 'bar)

;; don't stop blinking at all
(setq blink-cursor-blinks 0)

;; override insert key to change cursor in overwrite mode
(defvar cursor-mode-status 0)
(global-set-key (kbd "<insert>")
       (lambda () (interactive)
         (cond ((eq cursor-mode-status 0)
            (setq cursor-type 'box)
            (overwrite-mode (setq cursor-mode-status 1)))
           (t
            (setq cursor-type 'bar)
            (overwrite-mode (setq cursor-mode-status 0))))))
#+END_SRC

Adaptive cursor width shows width of character, e.g. TAB. Via [[http://pragmaticemacs.com/emacs/adaptive-cursor-width/][Pragmatic Emacs]].
#+BEGIN_SRC emacs-lisp
(setq x-stretch-cursor t)
#+END_SRC

I also like a highlight on the screen to show the current cursor line.  =global-hl-line-mode= softly highlights the
background color of the line containing point. It makes it a bit easier to find point, and it's useful when pairing or
presenting code.

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode)
#+END_SRC

Make sure we edit using visual lines, instead of actual line breaks.
Helps when word wrapping is on.

#+BEGIN_SRC emacs-lisp :results none
 (global-visual-line-mode t)
#+END_SRC

Give actual selections another color
#+BEGIN_SRC emacs-lisp :results none
 (set-face-attribute 'region nil :background "#666" :foreground "#ffffff")
#+END_SRC

*** Turn off unnecessary graphical features
**** Startup Messages

Don't display the help screen on startup.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t
      initial-scratch-message ""
      inhibit-startup-echo-area-message t)

#+END_SRC

**** Tool Bar
Let's turn off unwanted window decorations.

#+BEGIN_SRC emacs-lisp
;  (tool-bar-mode -1)
;  (scroll-bar-mode -1)

(if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
(if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))

#+END_SRC

*** Mode Line
Fancy up the mode line a little bit.

#+BEGIN_SRC emacs-lisp
 (use-package telephone-line
     :ensure t
     :config (telephone-line-mode 1))
#+END_SRC
*** Titlebar
Improve look and feel of titlebar on Macos. Set =ns-appearance= to =dark=
for white title text and =nil= for black title text.

Show the full path of the current file in the TitleBar.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  (add-to-list 'default-frame-alist '(ns-appearance . dark))

(setq frame-title-format
      '(buffer-file-name "%b - %f" ; File buffer
        (dired-directory dired-directory ; Dired buffer
         (revert-buffer-function "%b" ; Buffer Menu
          ("%b - Dir: " default-directory))))) ; Plain buffer

#+END_SRC

** Editing
*** Vim Emulation

[http://www.emacswiki.org/emacs/Evil][Evil mode]] provides vim-style keybindings for emacs. It makes it much more usable for a long-time vim user. [[https://github.com/timcharper/evil-surround][Evil-surround]]
is an emacs wrapper of Tim Pope's [[https://github.com/tpope/vim-surround][vim-surround]] plugin. [[https://github.com/krisajenkins/evil-tabs][Evil-tabs]] is an emacs mode that allows tabs with vim's tab
keybindings.

#+BEGIN_SRC emacs-lisp :results none
(use-package evil
  :diminish
  :config (evil-mode) ; Enable evil mode globally
)

(use-package evil-surround
  :defer t
  :diminish
  :config (global-evil-surround-mode t)
)

(use-package evil-tabs
  :defer t
  :diminish
  :config (global-evil-tabs-mode t)
)

#+END_SRC

By default emacs doesn't tab indent to the current level when you hit return. Move to vim style.

Note: actually electric-indent-mode is used for this.

#+BEGIN_SRC emacs-lisp :results none
(global-set-key (kbd "RET") 'newline-and-indent)
#+END_SRC

*** Encoding
In order to avoid issues with extra EOL characters (^M) being passed with =Tramp= it is probably a good idea to set the
file encoding to that of the remote system which is Linux (Unix) in this case. You can alwasy change the file encoding
later with M-x =set-buffer-file-coding-system= command.

Below I define some sensible defaults for working with different [[https://www.masteringemacs.org/article/working-coding-systems-unicode-emacs][coding systems]]

#+BEGIN_SRC emacs-lisp
(setq inhibit-compacting-font-caches t) ;fix unicode slowness
(setq utf-translate-cjk-mode nil) ; disable CJK coding/encoding (Chinese/Japanese/Korean characters)
(set-language-environment 'utf-8)
(set-keyboard-coding-system 'utf-8)
(setq locale-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
 (set-selection-coding-system
    (if (eq system-type 'windows-nt)
        'utf-16-le  ;; https://rufflewind.com/2014-07-20/pasting-unicode-in-emacs-on-windows
      'utf-8))
(prefer-coding-system 'utf-8)

 ;; backwards compatibility as default-buffer-file-coding-system
 ;; is deprecated in 23.2.
; (if (boundp 'buffer-file-coding-system)
;     (setq-default buffer-file-coding-system 'utf-8)
;   (setq default-buffer-file-coding-system 'utf-8))

 ;; Treat clipboard input as UTF-8 string first; compound text next, etc.
; (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+END_SRC

Emacs recognizes which kind of end-of-line conversion to use based on the contents of the file: if it sees only
carriage-returns, or only carriage-return linefeed sequences, then it chooses the end-of-line conversion accordingly.
However I like to suppress the automatic use of end-of-line conversion, this results in DOS-files displaying the ^M
(Carriage Return)character visible in the buffer.

#+BEGIN_SRC emacs-lisp
(setq inhibit-eol-conversion t)
#+END_SRC
*** Line Wrapping
I prefer lines to wrap. I find a 120 character line length is best for modern
screens. Individual languages/major modes can override this. In text-based modes
 (non-programming modes) I enable automatic line wrapping also.

#+BEGIN_SRC emacs-lisp :results none
  (setq-default fill-column 120)
  (add-hook 'text-mode-hook 'auto-fill-mode)
#+END_SRC
*** Trailing Whitespace
Delete trailing whitespace automatically on save. I used to configure editors to highlight trailing whitespace, but it's
pointless if it can be auto-deleted on save.

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** Security
*** TLS
*** Encryption
** Backups
I find Emacs default behavior of saving files relative to the current directory annoying, as it puts backup files
everywhere. Instead, this saves backups in one directory, a backup folder within my Emacs directory.

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist '(("." . "~/.emacs.d/backup"))
    backup-by-copying t    ; Don't delink hardlinks
    version-control t      ; Use version numbers on backups
    delete-old-versions t  ; Automatically delete excess backups
    kept-new-versions 20   ; how many of the newest versions to keep
    kept-old-versions 5    ; and how many of the old
    )
#+END_SRC

** Programming
*** Languages
Specify the [[https://orgmode.org/manual/Languages.html][languages]] we use in org-mode code blocks, which are:
1. sh: plain shell scripts for (Literate) Devops tasks;
2. dot: for drawing diagrams with the aid of GraphViz;
3. plantuml: for drawing diagram with the aid of PlantUML;

#+BEGIN_SRC emacs-lisp
(when (= emacs-major-version 25)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '(
     (sh . t)
     (python . t)
     (dot . t)
     (plantuml . t)
     (ditaa .t)
     )))

(when (= emacs-major-version 26)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '(
     (shell . t)
     (python . t)
     (dot . t)
     (plantuml . t)
     (ditaa .t)
     )))

#+END_SRC
** Diagramming
*** Ditaa

 Tell Org mode where the ditaa.jar file is:

 #+BEGIN_SRC emacs-lisp
 (setq org-ditaa-jar-path (expand-file-name "~/Bin/Ditaa/ditaa.jar"))
 #+END_SRC

*** Graphviz
 https://vxlabs.com/2014/12/04/inline-graphviz-dot-evaluation-for-graphs-using-emacs-org-mode-and-org-babel/

Add the graphviz dot command to the loading path
#+BEGIN_SRC emacs-lisp
(when (eq window-system 'w32)

  (setq graphviz-directory (expand-file-name "~/Bin/graphviz/bin"))
  (when (and (not (string-match graphviz-directory (getenv "PATH")))
	     (file-directory-p graphviz-directory))
    (setenv "PATH" (concat graphviz-directory ";" (getenv "PATH")))
    (add-to-list 'exec-path graphviz-directory))
)
#+END_SRC

*** PlantUML
    :PROPERTIES:
    :link:     http://www.alvinsim.com/diagrams-with-plantuml-and-emacs/
    :END:

 Tell Org mode where the plantuml.jar file is by using the code snippet below.
 #+BEGIN_SRC emacs-lisp
 (setq org-plantuml-jar-path (expand-file-name "~/Bin/plantuml/plantuml.jar"))
 #+END_SRC

 In order to be able to use PlantUML stereotype in combination with orgmode's noweb functionality we need to change the
 noweb markers to something else

 #+BEGIN_SRC emacs-lisp
 (setq org-confirm-babel-evaluate nil
         org-babel-noweb-wrap-start "{{{"
         org-babel-noweb-wrap-end "}}}")

 ;(setq org-babel-noweb-wrap-start: "{{{")
 ;(setq  org-babel-noweb-wrap-end: "}}}")
 #+END_SRC
** Tramp
For working on remote system via =Tramp= we use =plink= as the default method.

#+BEGIN_SRC emacs-lisp
(require 'tramp)
(add-to-list 'tramp-remote-path 'tramp-own-remote-path)

(when (eq window-system 'w32)
  (setq tramp-default-method "plink")
  (setq tramp-password-end-of-line "\r\n")
  (setq tramp-connection-timeout 300)
  (set-default 'tramp-auto-save-directory (expand-file-name "~/AppData/Local/Temp"))
  (setq putty-directory (expand-file-name "~/Bin/putty"))
  (when (and (not (string-match putty-directory (getenv "PATH")))
	     (file-directory-p putty-directory))
    (setenv "PATH" (concat putty-directory ";" (getenv "PATH")))
    (add-to-list 'exec-path putty-directory))
)

#+END_SRC

#+BEGIN_SRC emacs-lisp
;; (setq password-cache nil)

;; (setq tramp-password-prompt-regexp
;;        "^.*\\([pP]assword\\|Using keyboard-interactive authentication\\|[vV]erification code.*\\):\\|\.\^@? *" )
#+END_SRC

** Clocking

I'd like my clock reports to display hours worked instead of days

#+BEGIN_SRC emacs-lisp :results none
(setq org-time-clocksum-format (quote (:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t)))
(setq org-duration-format (quote h:mm))
#+END_SRC

** Various
*** Default Home
Set the =%HOME%= as the default directory for Emacs

#+BEGIN_SRC emacs-lisp
(setq default-directory "~/" )
#+END_SRC

*** Bell
Since I don't like the terminal bell I've replaced it with a visual cue.

#+BEGIN_SRC emacs-lisp
  (defun my-terminal-visible-bell ()
      "A friendlier visual bell effect."
      (invert-face 'mode-line)
      (run-with-timer 0.1 nil 'invert-face 'mode-line))

  (setq visible-bell nil
      ring-bell-function 'my-terminal-visible-bell)
#+END_SRC
*** Prompts
Make the =yes or no= prompts shorter.

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

* Packages
Installation and configuration of additional packages to make Emacs even more awesome.
** Shells
Over time, I've come to prefer Eshell over shell mode or Ansi-term. The main features I tend to use are setting aliases,
executing e-Lisp, and writing command output to a buffer.
*** Eshell

#+BEGIN_SRC emacs-lisp
    (use-package eshell
      :bind (("<f1>" . eshell))
      :hook ((eshell-mode . with-editor-export-editor)
	     (eshell-mode . setup-company-eshell-autosuggest))
      :init
      (setq eshell-banner-message "")

      (defun new-eshell ()
	(interactive)
	(eshell 'true))

      ;; (use-package company-eshell-autosuggest
      ;;   :init
      ;;   (defun setup-company-eshell-autosuggest ()
      ;;     (with-eval-after-load 'company
      ;;       (setq-local company-backends '(company-eshell-autosuggest))
      ;;    (setq-local company-frontends '(company-preview-frontend)))))
  )
#+END_SRC

*** Shell Mode

** Directories and Files (Dired)
 For me, Dired is one of Emacs' (less-heralded) killer apps, along with Org-Mode and Magit.


 Some of these suggestions are adapted from Xah Lee's [[http://ergoemacs.org/emacs/emacs_dired_tips.html][article on Dired]]. dired-find-alternate-file, which is bound to a,
 is disabled by default. <return> was previously dired-advertised-find-file, and ^ was previously
 dired-up-directory. Relatedly, I re-bind 'q' to my kill-this-buffer function below.

 Dired-details lets me show or hide the details with ) and (, respectively. If, for some reason, it becomes hard to
 remember this, dired-details+ makes the parentheses interchangeable.

** Key Bindings
*** Hydra
[[https://github.com/abo-abo/hydra][Hydra]] is a package for GNU Emacs that can be used to tie related commands into a family of short bindings with a common
prefix - a Hydra.

#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :config
    (setq hydra-lv nil))
#+END_SRC

** Window Management

Adapted from [[https://github.com/sachac/.emacs.d/blob/gh-pages/Sacha.org#make-window-splitting-more-useful][Sacha's config]] and a [[https://www.reddit.com/r/emacs/comments/25v0eo/you_emacs_tips_and_tricks/chldury][reddit comment]].

#+BEGIN_SRC emacs-lisp
  (defun vsplit-last-buffer ()
    (interactive)
    (split-window-vertically)
    (other-window 1 nil)
    (switch-to-next-buffer))

  (defun hsplit-last-buffer ()
    (interactive)
    (split-window-horizontally)
    (other-window 1 nil)
    (switch-to-next-buffer))

  (bind-key "C-x 2" 'vsplit-last-buffer)
  (bind-key "C-x 3" 'hsplit-last-buffer)
#+END_SRC

**** Zoom Mode
This replaces Golden Ratio mode.

#+BEGIN_SRC emacs-lisp
  (use-package zoom
    :init
    (setq zoom-mode t
          zoom-size '(0.618 . 0.618)))
#+END_SRC

** Jumping
*** Jump to Characters and Words

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :bind ("M-SPC" . avy-goto-char)
    :config
    (setq avy-background t
          avy-keys '(?a ?o ?e ?u ?i ?d ?h ?t ?n ?s)))
#+END_SRC

*** Jump to Windows

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :bind (("C-x o" . ace-window)
           ("M-2" . ace-window))
    :init
    (setq aw-background nil
          aw-keys '(?a ?o ?e ?u ?i ?d ?h ?t ?n ?s)))
#+END_SRC

** Programming and Development
*** Programming Languages
**** Golang
:PROPERTIES:
:link:     https://andrewjamesjohnson.com/configuring-emacs-for-go-development/
:link:     http://tleyden.github.io/blog/2014/05/22/configure-emacs-as-a-go-editor-from-scratch/
:END:

The first thing you’ll need for Go development in Emacs is =go-mode=

# #+BEGIN_SRC emacs-lisp
#     (use-package go-mode
#       :ensure t
#       :bind (("C-c C-r" . go-remove-unused-imports)
# 	     ("C-c C-g" . go-goto-imports)
# 	     ("C-c C-f" . gofmt)
# 	     ("C-c C-k" . godoc))
#       :config
#       (progn
#        ; (setenv "GOPATH" "/home/inkel/dev/go")
# 	(setq gofmt-command "goimports")
#     (add-hook 'before-save-hook 'gofmt-before-save)))
# #+END_SRC

Installing go-mode will also let you pull up documention on the standard library or third-party packages with M-x
godoc. To make godoc work correctly, you’ll need to make sure Emacs has the correct values of $PATH and $GOPATH.

**** Visual Basic

# #+BEGIN_SRC emacs-lisp :results none
#   (use-package visual-basic-mode
#    :load-path "lisp/")
#    (autoload 'visual-basic-mode "visual-basic-mode" "Visual Basic mode." t)
#    (setq auto-mode-alist (append '(("\\.\\(frm\\|bas\\|cls\\|vb\\)$" .
# 				   visual-basic-mode)) auto-mode-alist))
# #+END_SRC

*** Developing in Emacs
**** Line Numbers

 Turn linum-mode on/off with Command-K (see the Macintosh section above). However, I turn this on automatically for
 programming modes.


 #+BEGIN_SRC emacs-lisp :results none
   (use-package linum
     :init
     (add-hook 'prog-mode-hook 'linum-mode)
     (add-hook 'linum-mode-hook (lambda () (set-face-attribute 'linum nil :height 110)))

     :config
     (defun linum-fringe-toggle ()
       "Toggles the line numbers as well as the fringe."    (interactive)
       (cond (linum-mode (fringe-mode '(0 . 0))
                         (linum-mode -1))
             (t          (fringe-mode '(8 . 0))
                         (linum-mode 1))))

     :bind (("A-C-k"   . linum-mode)
            ("s-C-k"   . linum-mode)
            ("A-C-M-k" . linum-fringe-toggle)
            ("s-C-M-k" . linum-fringe-toggle)))
 #+END_SRC

**** Indentation

Keep things indented correctly for me.
 #+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :init
  (global-aggressive-indent-mode 1)
  (add-to-list 'aggressive-indent-excluded-modes 'html-mode)
  (unbind-key "C-c C-q" aggressive-indent-mode-map))
 #+END_SRC

**** Commenting
** Calendar
** Writing
=writegood-mode= highlights bad word choices and has functions for calculating readability.

#+BEGIN_SRC emacs-lisp
  (use-package writegood-mode
    :ensure t
    :bind ("C-c g" . writegood-mode)
    :config
    (add-to-list 'writegood-weasel-words "actionable"))
#+END_SRC

** Exporting
*** Html
Install Htmlize to ensure exporting to Html is possible.
#+BEGIN_SRC emacs-lisp :results none
(use-package htmlize
  :commands (htmlize-buffer
             htmlize-file
             htmlize-many-files
             htmlize-many-files-dired
             htmlize-region))
#+END_SRC
*** Latex
Load custom latex classes

#+BEGIN_SRC emacs-lisp :results none
(setq org-latex-listings 'listings)
(require 'ox-latex)
(add-to-list 'org-latex-packages-alist '("" "listings"))

;(setq org-latex-minted-options
;        '(("frame" "lines") ("linenos=true")))

;(setq org-latex-pdf-process
;      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
;        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
;        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

;(setq org-src-fontify-natively t)
(defun get-string-from-file (filePath)
  "Return filePath's file content."
  (with-temp-buffer
    (insert-file-contents filePath)
    (buffer-string)))

(defun read-lines (filePath)
  "Return a list of lines of a file at filePath."
  (with-temp-buffer
    (insert-file-contents filePath)
    (split-string (buffer-string) "\n" t)))

(mapc 'load (file-expand-wildcards "~/.emacs.d/publishing/latex/*/*.el"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results none
(use-package ox-reveal
  :ensure ox-reveal)
#+END_SRC

*** Resume
#+BEGIN_SRC emacs-lisp :results none
;(use-package ox-moderncv
;    :load-path "~/.emacs.d/lisp/org-cv/"
;    :init (require 'ox-moderncv))
#+END_SRC
** Importing
=org-protocol= allows external processes to interact with some of org-mode's features.

#+BEGIN_SRC emacs-lisp :results none
(server-start)
(require 'org-protocol)

(setq org-capture-templates '(
    ("p" "Protocol" entry (file "~/org/inbox.org")
        "* %? [[%:link][%:description]] \n#+BEGIN_QUOTE\n%i\n#+END_QUOTE\n")
    ("L" "Protocol Link" entry (file "~/org/inbox.org")
        "* %? [[%:link][%:description]] \nCaptured On: %U")
))

(setq org-protocol-default-template-key "p")
#+END_SRC

* Key Bindings
** OS Specific
*** Windows

I need to come up with a good solution for binding the Meta, Super and Hyper keys in Windows:
 - http://ergoemacs.org/emacs/emacs_hyper_super_keys.html
 - https://emacs.stackexchange.com/questions/30260/emacs-super-key-modifier-on-caps-lock-in-windows-native-and-cygwin-emacs-w32/30263
 - https://www.emacswiki.org/emacs/MovingTheCtrlKey
 - https://www.reddit.com/r/emacs/comments/3oc3hn/what_do_you_map_super_to_on_windows_and_linux/
 - http://caiorss.github.io/Emacs-Elisp-Programming/Emacs_On_Windows.html

For now I think I'd like to swap Control with Caps Lock and use Control as the Super Key
In short, I'd like to use the following scheme in Windows if possible:
+ CapsLock: Control key
+ Alt: Meta key
+ Left Ctrl: Super key
+ Right Ctrl: Hyper key

#+BEGIN_SRC emacs-lisp
 ;; make PC keyboard's Win key or other to type Super or Hyper, for emacs running on Windows.
 (setq w32-pass-lwindow-to-system nil)
 (setq w32-lwindow-modifier 'hyper) ; Left Windows key

 (setq w32-pass-rwindow-to-system nil)
 (setq w32-rwindow-modifier 'super) ; Right Windows key

 (setq w32-pass-apps-to-system nil)
 (setq w32-apps-modifier 'super) ; Menu/App key
#+END_SRC

*** OS X

#+BEGIN_SRC emacs-lisp
   (when (is-mac-p)
     (setq mac-command-modifier 'meta
           mac-option-modifier 'super
           mac-control-modifier 'control
           ns-function-modifier 'hyper))
#+END_SRC

** Clocking

Since there are a *lot* of commands for clocking in; this is a perfect instance for a Hydra.

The Hydra below is used for clocking in orgmode:

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c w" 'hydra-org-clock/body)

  (defhydra hydra-org-clock (:color blue :hint nil)
    "
  Clock   In/out^     ^Edit^   ^Summary     (_?_)
  -----------------------------------------
	  _i_n         _e_dit   _g_oto entry
	  _c_ontinue   _q_uit   _d_isplay
	  _o_ut        ^ ^      _r_eport
	"
    ("i" org-clock-in)
    ("o" org-clock-out)
    ("c" org-clock-in-last)
    ("e" org-clock-modify-effort-estimate)
    ("q" org-clock-cancel)
    ("g" org-clock-goto)
    ("d" org-clock-display)
    ("r" org-clock-report)
    ("?" (org-info "Clocking commands")))
#+END_SRC

We also write a similar (pared down) map for using the same functionality from the agenda:

#+BEGIN_SRC emacs-lisp

  (defhydra hydra-org-agenda-clock (:color blue :hint nil)
    "
  Clock   In/out^
  -----------------------------------------
	  _i_n
	  _g_oto entry
	  _o_ut
	  _q_uit
	"
    ("i" org-agenda-clock-in)
    ("o" org-agenda-clock-out)
    ("q" org-agenda-clock-cancel)
    ("g" org-agenda-clock-goto))

  ;; (setq org-agenda-mode-map nil)
  ;; (bind-keys ("C-c w" . hydra-org-clock/body)
  ;;            :map org-agenda-mode-map
  ;;            ("C-c w" . hydra-org-agenda-clock/body))
#+END_SRC

#+RESULTS:
: hydra-org-agenda-clock/body

** Zooming
The keys to increase and decrease the scale are consistent with the default =C-x C-+= and =C-x C--= bindings,
respectively.

#+BEGIN_SRC emacs-lisp
  (defhydra hydra-zoom ()
    "zoom"
    ("+" text-scale-increase "in")
    ("=" text-scale-increase "in")
    ("-" text-scale-decrease "out")
    ("_" text-scale-decrease "out")
    ("0" (text-scale-adjust 0) "reset")
    ("q" nil "quit" :color blue))

  (bind-keys ("C-x C-0" . hydra-zoom/body)
             ("C-x C-=" . hydra-zoom/body)
             ("C-x C--" . hydra-zoom/body)
             ("C-x C-+" . hydra-zoom/body))
#+END_SRC

* Functions
** Emacs Configuration File

This function and the corresponding keybinding allows me to rapidly access my configuration. They are adapted from
Bozhidar Batsov's [[http://emacsredux.com/blog/2013/05/18/instant-access-to-init-dot-el/][post on Emacs Redux]].

We bind the shortcut =C-c i= to open up this configuration file, which makes it easy to view and/or edit the
configuration.

#+BEGIN_SRC emacs-lisp
  (defun find-init-file ()
    "Edit my init file in another window."
    (interactive)
    (let ((mwf-init-file "~/.emacs.d/rkiggen.org"))
      (find-file mwf-init-file)))

  (bind-key "C-c i" 'find-init-file)
#+END_SRC

Relatedly, I often want to reload my init-file. This will actually use the system-wide user-init-file variable.

#+BEGIN_SRC emacs-lisp
  (defun reload-init-file ()
    "Reload my init file."
    (interactive)
    (load-file user-init-file))

  (bind-key "C-c M-r" 'reload-init-file)
#+END_SRC

** Full Screen

#+BEGIN_SRC emacs-lisp
(defun toggle-full-screen () (interactive) (shell-command "emacs_fullscreen.exe"))
(global-set-key [f11] 'toggle-full-screen)
#+END_SRC

* Capture Templates

Define your capture templates:

#+BEGIN_SRC emacs-lisp
  (defun my-new-daily-review ()
    (interactive)
    (let ((org-capture-templates '(("d" "Review: Daily Review" entry (file+olp+datetree "~/Org/reviews.org")
                                    (file "~/Org/templates/dailyreviewtemplate.org")))))
      (progn
        (org-capture nil "d")
        (org-capture-finalize t)
        (org-speed-move-safe 'outline-up-heading)
        (org-narrow-to-subtree)
        (fetch-calendar)
        (org-clock-in))))

(bind-keys :prefix-map review-map
             :prefix "C-c r"
             ("d" . my-new-daily-review)
             ("w" . my-new-weekly-review)
             ("m" . my-new-monthly-review))

#+END_SRC

* Workflow Setup
** Organization (GTD and PARA)
:PROPERTIES:
:source: https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html
:github: https://github.com/NicolasPetton/emacs.d
:END:

I've split my GTD in four separate files:
1. inbox.org: where I collect everything;
2. gtd.org: where I put all my projects;
3. someday.org: all inactive tasks that I might do at some point in the future, but don’t want to see all the time;
4. tickler.org: I put entries in this file with a timestamp to get reminded at the right moment.

It’s important to add these files to the agenda file (more on the agenda later), like the following:

# #+BEGIN_SRC emacs-lisp :results none
# (setq org-agenda-files '("~/gtd/inbox.org"
# 			"~/gtd/projects.org"
# 			"~/gtd/tickler.org"))
# #+END_SRC

** The GTD inbox

One of the most important aspects of GTD is the inbox. Every thought should be collected there, and processed later
on.

Orgmode has a great feature that fits really well with this concept: org-capture.Capturing a thought is one key press
away: simply Press C-c c, and a capture popup will appear in Emacs.

Once you’re done capturing, C-c C-c and it will get stored in the inbox.Here’s how I set it up:

# #+BEGIN_SRC emacs-lisp :results none
# (define-key global-map "\C-cc" 'org-capture)

# (setq org-capture-templates '())

# (add-to-list 'org-capture-templates
# 	'("t" "Todo [inbox]" entry (file "~/gtd/inbox.org")
# 	"* TODO %i%?"))

# (add-to-list 'org-capture-templates
# 	'("T" "Tickler" entry (file+headline "~/gtd/tickler.org" "Tickler")
# 	"* %i%? \nSCHEDULED: %^t"))
# #+END_SRC

The syntax of capture templates is explained here. It offers lots of customization options.
I press C-c c t to add an entry to my inbox, and C-c c T to add an entry to the tickler (more on that later).

My inbox is then processed and emptied daily. When processing the inbox, I refile each entry that is actionable and
belongs to a project using C-c C-w, moving the entry to the appropriate place. If need be, I create a new project out of
it.

I have set up the refile targets as follows:

# #+BEGIN_SRC emacs-lisp :results none
# (setq org-refile-targets '(("~/gtd/projects.org" :maxlevel . 3)
#                            ("~/gtd/someday.org" :level . 1)
#                            ("~/gtd/tickler.org" :maxlevel . 2)))
# #+END_SRC

So that C-c C-w prompts me either for a project, the tickler, or someday/maybe list.

** The projects file
My main file is gtd.org. That’s where I keep all my active projects

Each project contains actions to be performed. The first action of each project is called its “next action”, and that’s
always the one I will do when working on a project. Once a task is done, I mark it as such using the =DONE= todo
keyword.

*** Tags

Tagging is done using C-c C-c on a headline, whether it’s a project or action. I use tags for several purposes:
- Regular categories, like :emacs: or :writing:;
- Tags that link to people, like :daniel:;
- GTD contexts;

GTD contexts are just regular tags, starting with @. I make heavy use of them in custom Org Agenda commands.
My contexts tend to change over time, but I always have at least @home, @office, @travelling, @phone, @email, @errands
to filter out next actions based on my current location for instance.

*** TODO keywords

I put a todo keyword in all project entries. I think I use fairly regular todo keywords: TODO, WAITING, DONE and
CANCELLED mostly. The first two for are used for incomplete states, and the last two for completed states.

# #+BEGIN_SRC emacs-lisp :results none
# (setq org-todo-keywords '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)")))
# #+END_SRC

When on a headline, press C-c C-t to set the TODO keyword.

*** Timestamps, scheduling & deadlines

I tend to avoid using timestamps in my projects as much as possible. The reason is simple: unless an entry is an
appointment (to the dentist for instance) or has a fixed deadline (a release scheduled with a customer), I should decide
what to work on depending on the current context (among other things). This also keeps my agenda clean, free of any fake
or self-imposed deadline or schedule.

But scheduling sometimes makes sense. To do that, press C-c C-s on an entry, and enter the date and/or time. To add a
deadline, press C-c C-d. Note that Orgmode is quite smart about how you can enter a date, if you don’t know about it,
refer to the manual entry.

*** Filtering projects & actions

When deciding what to work on, I use either sparse trees – which makes it easy to filter the content of my GTD projects
by tag, search term, etc., or I use custom agenda commands. When discovering Orgmode, most people think that its agenda
is just a regular agenda. Sure, it does daily/weekly agendas, but it offers much more than that. Quoting the manual:

#+BEGIN_QUOTE
Org-mode’s built-in agenda commands are powerful tools for searching your notes and for gathering, sorting, filtering,
and displaying your tasks.
#+END_QUOTE

I use custom agenda commands mostly to get an overview of actions by context or tag. Here’s an example custom agenda
command that will display all actions for the @office context:

#+BEGIN_SRC emacs-lisp :results none
;(setq org-agenda-custom-commands
;      '(("o" "At the office" tags-todo "@office"
;         ((org-agenda-overriding-header "Office")))))
#+END_SRC

Following the GTD principle, what I usually want is to only show the first action to be done (or next action) for each
project with the @office tag.

That can be achieved using a skipping condition:

# #+BEGIN_SRC emacs-lisp :results none
# (setq org-agenda-custom-commands
#       '(("o" "At the office" tags-todo "@office"
#          ((org-agenda-overriding-header "Office")
#           (org-agenda-skip-function #'my-org-agenda-skip-all-siblings-but-first)))))

# (defun my-org-agenda-skip-all-siblings-but-first ()
#   "Skip all but the first non-done entry."
#   (let (should-skip-entry)
#     (unless (org-current-is-todo)
#       (setq should-skip-entry t))
#     (save-excursion
#       (while (and (not should-skip-entry) (org-goto-sibling t))
#         (when (org-current-is-todo)
#           (setq should-skip-entry nil))))
#     (when should-skip-entry
#       (or (outline-next-heading)
#           (goto-char (point-max))))))

# (defun org-current-is-todo ()
#   (string= "TODO" (org-get-todo-state)))
# #+END_SRC

** Refiling configuration

What I want to be able to do is, move project nodes from my inbox.org to some location in gtd.org, either under a
parent node for some existing project, or at the top level, as an entirely new project.

*** Refile to the Top Level

You may have noticed that all of the targets listed are existing headings. So how can you refile a node to the top level
within a file? To do that, we’ll need to reconfigure the way Org generates the targets to be aware of their outline
paths.

This is sort of a trick; you will have a generally cleaner and prettier experience with Refile if you don’t need to do
this, but this is the only way to do top-level refiles. We configure org-refile-use-outline-path to tell Org to include
the destination file as an element in the path to a heading, and to use the full paths as completion targets rather than
just the heading text itself.


What this results in is a targets listing containing forward-slash-delimited filenames and headings, as though they were
paths on disk. Because the filename also appears by itself, you can select that to refile to the top level of the file.

# #+BEGIN_SRC emacs-lisp :results none
# (setq org-refile-use-outline-path 'file)
# #+END_SRC

But, if you use Helm, which you really should, you will notice that as soon as you set this option, your target list
contains only one filename. Typing to complete may allow you to find another filename within your agenda files, but you
will only ever see a filename; no other headings ever appear! Why is that?!

It took a bit of searching to find this solution. This is because the default behavior for Refile is to allow you to do
a step-by-step completion of this path, but if you’re using Helm, Helm is overriding the completing read to make it into
a narrowing list (that we have all come to love).

So what you need to do is tell Org that you don’t want to complete in steps; you want Org to generate all of the
possible completions and present them at once. Helm then lets you narrow to the one you want.

# #+BEGIN_SRC emacs-lisp :results none
# (use-package helm
#   :ensure t
#   :diminish helm-mode
#   :commands helm-mode
#   :config
#   (helm-mode 1)
#   (setq helm-buffers-fuzzy-matching t)
#   (setq helm-autoresize-mode t)
#   (setq helm-buffer-max-length 40)
#   (define-key helm-map (kbd "S-SPC") 'helm-toggle-visible-mark)
#   (define-key helm-find-files-map (kbd "C-k") 'helm-find-files-up-one-level))
# #+END_SRC


# #+BEGIN_SRC emacs-lisp :results none
# (setq org-outline-path-complete-in-steps nil)
# #+END_SRC

*** Creating New Parents

Occasionally you may want to refile something into another file or heading and place it beneath a new parent that you
create on-the-fly. If you do not set up this configuration, you will not be able to create new parents during refile, so
I recommend setting it up.

# #+BEGIN_SRC emacs-lisp :results none
# (setq org-refile-allow-creating-parent-nodes 'confirm)
# #+END_SRC

This means “allow me to tack new heading names onto the end of my outline path, and if I am asking to create new ones,
make me confirm it.” For the simplest case, you allow Helm to narrow to what you want and hit RET and you’re done. If
you want to create a new heading, you must add /New Heading to the end, and upon accepting that entry, Org will prompt
you to confirm that you want to create a new heading called “New Heading.”

This can be useful if you are refiling a bunch of stuff and you have an idea of the new structure you want and you don’t
want to have to bounce between files creating new parent headings that will become targets. You can just use Refile
itself to build the structure that you want.

* Appendix
** Inspiration
*** Configuration
https://github.com/mwfogleman/.emacs.d/blob/master/michael.org

** Tramp
*** Tramp Decoding Bug
If you receive a Decode error while executing a remote command, something along the lines of:

#+BEGIN_EXAMPLE
Tramp: Decoding remote file `/ssh:x.y.z:/var/folders/0s/pcrc3rq5075gj4tm90pbh76c36sl1h/T/ob-input-32379ujY' using `base64 -d -i >%s'...failed
byte-code: Couldn't write region to `/ssh:x.y.z:/var/folders/0s/pcrc3rq5075gj4tm90pbh76c36sl1h/T/ob-input-32379ujY', decode using `base64 -d -i >%s' failed
#+END_EXAMPLE

Then you should know that this happens because Tramp uses the TEMP directory from the local system and uses that as the
TEMP for the remote system, which won't work if your local system is Windows and the remote is Linux.

In order to solve this we need to change the =org-babel-temp-file= function  =ob-core.el= file and don't forget to
delete the corresponding .elc file afterwards.

# #+BEGIN_SRC emacs-lisp
# (defun org-babel-temp-file (prefix &optional suffix)
#   "Create a temporary file in the `org-babel-temporary-directory'.
# Passes PREFIX and SUFFIX directly to `make-temp-file' with the
# value of `temporary-file-directory' temporarily set to the value
# of `org-babel-temporary-directory'."
#   (if (file-remote-p default-directory)
#       (let ((prefix
#              ;; We cannot use `temporary-file-directory' as local part
#              ;; on the remote host, because it might be another OS
#              ;; there.  So we assume "/tmp", which ought to exist on
#              ;; relevant architectures.
#              (concat (file-remote-p default-directory)
#                      ;; REPLACE temporary-file-directory with /tmp:
#                      (expand-file-name prefix "/tmp/"))))
#         (make-temp-file prefix nil suffix))
#     (let ((temporary-file-directory
#            (or (and (boundp 'org-babel-temporary-directory)
#                     (file-exists-p org-babel-temporary-directory)
#                     org-babel-temporary-directory)
#                temporary-file-directory)))
#       (make-temp-file prefix nil suffix))))
# #+END_SRC

** Diagramming
Architectural Diagrams with ditaa
- https://www.johndcook.com/blog/2016/06/15/ascii-art-diagrams-in-emacs-org-mode/

Activity Diagrams:
- http://irreal.org/blog/?p=2866
- https://orgmode.org/worg/org-tutorials/org-dot-diagrams.html

Entity Relationship Diagrams:
- https://spin.atomicobject.com/2017/11/15/table-rel-diagrams-graphviz/
- http://mamchenkov.net/wordpress/2015/08/20/graphviz-dot-erds-network-diagrams/

Other:
- https://tomassetti.me/an-approach-to-uml-diagrams-and-er-models-bearable-for-a-software-engineer/
- http://www.coli.uni-saarland.de/~slemaguer/emacs/main.html#org1ae3303
